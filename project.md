* 说一下你项目中用到的技术栈，以及觉得得意和出色的点，以及让你头疼的点，怎么解决的
  1. 赛事实况：由于是实况较多情况需要实时，所以对于数据的缓存是根据业务做考究的，将所有接口单独抽离，判断 vuex 中是否已存在，若不存在才请求，降低请求次数，webpack 多入口分离组件库、框架、与业务代码，避免单包过大导致加载时过长的白屏情况，针对整点清除每个被点赞对象 10 次限制次数，使用 vuex 更新被点赞对象状态，第一次超过 10 次后，对象 uid 为 false，判断点击后直接返回提示不再请求接口，第一次更新点赞状态便创建到整点的一次性定时器清除点赞对象内所有被点用户状态，达到在不重启应用（刷新页面）的条件下整点清空状态，点赞限制由 redis 存储。
  2. 插件化报名表单与分享选项，由于报名表单由开始的单页需要到后续增加至多页需求以及每场赛事初始弹窗填写，所以将其插件化，抽离报名与取消按钮事件作为插件 api 回调灵活使用，分享插件化是因为需判断 app 内与 app 外，填写不同的分享选项及表现形式，如 app 内直接唤起分享栏，微信内出现指引图片，这栏主要是将组件和插件根据业务对应定制化，分离通用组件及业务插件、业务组件。
  3. 在使用 egg 做冲榜答题活动时
    * 将题目、答案、出现问题的时间段、答题时间段联合既有后台管理系统配置化，并可修改答案公布时间由此来配合脚本计算所有参与用户的积分并定时公布对应题目积分及用户总积分
    * 这里头疼的点不是在于配置化与设计，而是在于何时运行计分及答案公布脚本，题目时间段可通过请求接口时判断时间读表循环获取，但是更新答案的时间是不确定的，如果用户不请求接口触发，我们仍需跑一个定时脚本去解决这个排名与计分的问题，但是由于参与用户量的问题，我们又不可能依赖脚本过高的全量更新用户表，因为用户过多跑一次要很久，这种方法更新排行榜非常不可取。

    解决方案：
    1. 创建答题记录表，先行标记每个用户答题确认时的对错及所得分数；
    2. 每次请求排行榜时判断是否达到记录时间抽取达到时间的答题记录对用户总分进行批量更新，并标记本记录已更新，确保每次更新的量只在 2 题之间的答题用户量，降低批量更新的记录数；
    3. 写定时脚本去跑排行榜接口，避免没有用户请求排行榜接口也能更新排行榜数据；
    4. 前端也是我做的，由于没有使用 websocket，所以官方显示的榜单只能使用定时器去循环请求排行榜接口确保前端的实时性

    总的来说解决方案很差，但是由于阿迪甲方对时间要求太赶，只能说算是勉强满足业务需求了。
  4. 根据 vue-init 设计适合公司 H5 活动使用的业务 vue-template。
  5. 搭建 egg 框架时遇到过 egg-bin 在 mac 下实时 watch 了 node_modules 的文件情况，查看源码发现 egg-bin 是最暴力的 fs.watch 整个项目文件目录，而不是递归 watch 项目目录下每个子目录，查看 issue 时发现 egg-watcher-chokidar 插件的存在，去忽略了 node_modules 目录的监听，否则恐怕要自己写插件。
  6. 还是问什么说什么吧，不一定一下子所有坑都想到，但是被问到肯定可以想起来。
